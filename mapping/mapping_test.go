// Copyright 2017 Tomas Machalek <tomas.machalek@gmail.com>
// Copyright 2017 Charles University, Faculty of Arts,
//                Institute of the Czech National Corpus
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

// Package mapping provides data types and functions used
// to manipulate numeric mapping between two aligned structures

package mapping

import (
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"
)

// ---- PosRange

func TestPosRangeLessThen(t *testing.T) {
	p1 := PosRange{1, 2}
	p2 := PosRange{1, 3}

	assert.True(t, p1.LessThan(p2))
	assert.False(t, p2.LessThan(p1))

	p3 := PosRange{1, 2}
	assert.False(t, p1.LessThan(p3))
	assert.False(t, p3.LessThan(p1))

	p4 := PosRange{2, 1}
	assert.True(t, p1.LessThan(p4))
	assert.False(t, p4.LessThan(p1))
}

func TestPosRangeString(t *testing.T) {
	p1 := PosRange{13, 29}
	assert.Equal(t, "13,29", p1.String())

	p2 := PosRange{-1, -1}
	assert.Equal(t, "-1", p2.String())
}

// ----- PosRange factories

func TestNewPosRangeOK(t *testing.T) {
	p, err := NewPosRange([]string{"2", "3"})
	assert.Nil(t, err)
	assert.Equal(t, 2, p.First)
	assert.Equal(t, 3, p.Last)
}

func TestNewPosRangeInvalid1(t *testing.T) {
	_, err1 := NewPosRange([]string{"2", "-1"})
	assert.Error(t, err1)

	_, err2 := NewPosRange([]string{"-1", "3"})
	assert.Error(t, err2)
}

func TestNewPosRangeInvalidOrientation(t *testing.T) {
	_, err := NewPosRange([]string{"10", "5"})
	assert.Error(t, err)
}

func TestNewPosRangeEmptyString(t *testing.T) {
	v, err := NewPosRange([]string{""})
	assert.Nil(t, err)
	assert.Equal(t, PosRange{-1, -1}, v)
}

func TestNewPosRangeSingleNumber(t *testing.T) {
	v, err := NewPosRange([]string{"12"})
	assert.Nil(t, err)
	assert.Equal(t, PosRange{12, 12}, v)
}

func TestNewPosRangeSingleNumberAndEmpty(t *testing.T) {
	_, err := NewPosRange([]string{"12", ""})
	assert.Error(t, err)
}

func TestNewPosRangeGibberishString(t *testing.T) {
	v, _ := NewPosRange([]string{"this is it"})
	assert.Equal(t, PosRange{-1, -1}, v)
}

// ---- Mapping

// note: there is no need to test individual values as they
// are generated by PosRange which is tested above

func TestMappingString(t *testing.T) {
	m := Mapping{PosRange{1, 2}, PosRange{3, 4}}
	assert.Equal(t, "1,2\t3,4", m.String())
}

// ---- Mapping factories

func TestNewMappingDefault(t *testing.T) {
	m := NewMapping(1, 2, 3, 4)
	assert.Equal(t, PosRange{1, 2}, m.From)
	assert.Equal(t, PosRange{3, 4}, m.To)
}

// the factory accepts also numbers we cannot
// meet in correct data
func TestNewMappingBadNumbers(t *testing.T) {
	m := NewMapping(-100, 20, -30, -2)
	assert.Equal(t, PosRange{-100, 20}, m.From)
	assert.Equal(t, PosRange{-30, -2}, m.To)
}

func TestNewMappingFromString(t *testing.T) {
	m1, err := NewMappingFromString("1,2\t3,4")
	assert.Nil(t, err)
	assert.Equal(t, 1, m1.From.First)
	assert.Equal(t, 2, m1.From.Last)
	assert.Equal(t, 3, m1.To.First)
	assert.Equal(t, 4, m1.To.Last)
}

func TestNewMappingFromStringEmpty(t *testing.T) {
	_, err := NewMappingFromString("")
	assert.Error(t, err)
}

func TestNewMappingFromStringInvalid(t *testing.T) {
	_, err1 := NewMappingFromString("-1,2\t3,3")
	assert.Error(t, err1)
	_, err2 := NewMappingFromString("1,2\t-1,4")
	assert.Error(t, err2)
}

func TestNewMappingFromStringPartial(t *testing.T) {
	v, err := NewMappingFromString("1,2\t")
	assert.Nil(t, err)
	assert.Equal(t, 1, v.From.First)
	assert.Equal(t, 2, v.From.Last)
	assert.Equal(t, -1, v.To.First)
	assert.Equal(t, -1, v.To.Last)
}

func TestNewMappingFromGibberishString(t *testing.T) {
	_, err := NewMappingFromString("this is it")
	assert.Error(t, err)
}

// -------- SortableMapping

func TestSortableMappingTypeA(t *testing.T) {
	mList := make([]Mapping, 4)
	mList[0] = Mapping{PosRange{1, 2}, PosRange{1, 3}}
	mList[1] = Mapping{PosRange{3, 4}, PosRange{4, 4}}
	mList[2] = Mapping{PosRange{5, 5}, PosRange{-1, -1}}
	mList[3] = Mapping{PosRange{6, 6}, PosRange{-1, -1}}
	smList := SortableMapping(mList)

	assert.True(t, smList.Less(0, 1))
	assert.False(t, smList.Less(1, 0))
	assert.True(t, smList.Less(1, 2))
	assert.True(t, smList.Less(2, 3))
}

func TestSortableMappingTypeB(t *testing.T) {
	mList := make([]Mapping, 3)
	mList[0] = Mapping{PosRange{-1, -1}, PosRange{1, 3}}
	mList[1] = Mapping{PosRange{-1, -1}, PosRange{4, 4}}
	smList := SortableMapping(mList)

	assert.True(t, smList.Less(0, 1))
}

func TestSortableMappingTypeInvalid(t *testing.T) {
	mList := make([]Mapping, 2)
	mList[0] = Mapping{PosRange{-1, -1}, PosRange{4, 4}}
	mList[1] = Mapping{PosRange{5, 5}, PosRange{-1, -1}}
	smList := SortableMapping(mList)

	assert.Panics(t, func() {
		smList.Less(0, 1)
	})
}

func TestSortableMappingSwap(t *testing.T) {
	mList := make([]Mapping, 3)
	m0 := Mapping{PosRange{1, 2}, PosRange{1, 3}}
	mList[0] = m0
	m1 := Mapping{PosRange{3, 4}, PosRange{4, 4}}
	mList[1] = m1
	m2 := Mapping{PosRange{-1, -1}, PosRange{5, 5}}
	mList[2] = m2
	smList := SortableMapping(mList)

	smList.Swap(0, 1)
	smList.Swap(1, 2)

	assert.Equal(t, smList[0], m1)
	assert.Equal(t, smList[1], m2)
	assert.Equal(t, smList[2], m0)

}

func TestSortableMappingSortingLen(t *testing.T) {
	mList := make([]Mapping, 3)
	mList[0] = Mapping{PosRange{1, 2}, PosRange{-1, -1}}
	mList[1] = Mapping{PosRange{3, 4}, PosRange{-1, -1}}
	mList[2] = Mapping{PosRange{5, 5}, PosRange{-1, -1}}
	smList := SortableMapping(mList)

	assert.Equal(t, 3, smList.Len())

	smList = append(smList, Mapping{PosRange{6, 6}, PosRange{0, 0}})

	assert.Equal(t, 4, smList.Len())
}

// Iterator

func TestIteratorFactory(t *testing.T) {
	mList := make([]Mapping, 4)
	mList[0] = Mapping{PosRange{1, 2}, PosRange{-1, -1}}
	mList[1] = Mapping{PosRange{3, 4}, PosRange{-1, -1}}
	mList[2] = Mapping{PosRange{5, 5}, PosRange{-1, -1}}
	mList[3] = Mapping{PosRange{6, 6}, PosRange{0, 0}}

	itr := NewIterator(mList)

	assert.True(t, itr.Unfinished())
}

func TestIteratorFactoryEmptyData(t *testing.T) {
	mList := make([]Mapping, 0)
	itr := NewIterator(mList)

	assert.True(t, itr.Unfinished())
}

func TestIteratorApplyFinishes(t *testing.T) {
	mList := make([]Mapping, 1)
	mList[0] = Mapping{PosRange{1, 2}, PosRange{-1, -1}}
	itr := NewIterator(mList)

	itr.Next()
	assert.True(t, itr.Unfinished())

	itr.Apply(func(v Mapping) {
	})

	assert.False(t, itr.Unfinished())
}

func TestIteratorCanApplyWithoutNext(t *testing.T) {
	mList := make([]Mapping, 1)
	mList[0] = Mapping{PosRange{1, 2}, PosRange{-1, -1}}
	itr := NewIterator(mList)
	itr.Apply(func(v Mapping) {
		assert.Equal(t, mList[0], v)
	})
}

func TestIteratorHasPriorityOver(t *testing.T) {
	mList := make([]Mapping, 4)
	mList[0] = Mapping{PosRange{1, 2}, PosRange{-1, -1}}
	mList[1] = Mapping{PosRange{3, 4}, PosRange{-1, -1}}
	mList[2] = Mapping{PosRange{5, 5}, PosRange{-1, -1}}
	mList[3] = Mapping{PosRange{6, 6}, PosRange{0, 0}}
	itr1 := NewIterator(mList)
	itr2 := NewIterator(mList)

	itr1.Next()
	itr2.Next()
	itr2.Next()
	assert.False(t, itr1.HasPriorityOver(&itr2)) // "to" values are in play

	itr2.Next()
	itr2.Next()
	assert.True(t, itr1.HasPriorityOver(&itr2)) // finally we're at (0, 0) against (-1, -1)
}

func TestMergeMappings(t *testing.T) {
	mList1 := make([]Mapping, 4)
	mList1[0] = Mapping{PosRange{1, 2}, PosRange{-1, -1}}
	mList1[1] = Mapping{PosRange{3, 3}, PosRange{1, 1}}
	mList1[2] = Mapping{PosRange{4, 5}, PosRange{4, 4}}
	mList1[3] = Mapping{PosRange{6, 6}, PosRange{6, 7}}

	mList2 := make([]Mapping, 2)
	mList2[0] = Mapping{PosRange{-1, -1}, PosRange{2, 3}}
	mList2[1] = Mapping{PosRange{-1, -1}, PosRange{5, 5}}

	i := 0
	ans := make([]Mapping, 6)
	MergeMappings(mList1, mList2, func(item Mapping) {
		ans[i] = item
		i++
	})

	assert.Equal(t, mList1[0], ans[0])
	assert.Equal(t, mList1[1], ans[1])
	assert.Equal(t, mList2[0], ans[2])
	assert.Equal(t, mList1[2], ans[3])
	assert.Equal(t, mList2[1], ans[4])
	assert.Equal(t, mList1[3], ans[5])
}

func TestMergeMappingsAlternatingItems(t *testing.T) {
	mList1 := make([]Mapping, 2)
	mList1[0] = Mapping{PosRange{1, 1}, PosRange{1, 1}}
	mList1[1] = Mapping{PosRange{2, 2}, PosRange{4, 4}}

	mList2 := make([]Mapping, 2)
	mList2[0] = Mapping{PosRange{-1, -1}, PosRange{2, 3}}
	mList2[1] = Mapping{PosRange{-1, -1}, PosRange{5, 5}}

	i := 0
	ans := make([]Mapping, 4)
	MergeMappings(mList1, mList2, func(item Mapping) {
		ans[i] = item
		i++
	})

	assert.Equal(t, mList1[0], ans[0])
	assert.Equal(t, mList2[0], ans[1])
	assert.Equal(t, mList1[1], ans[2])
	assert.Equal(t, mList2[1], ans[3])
}

func TestMergeMappingsWaitingColumn(t *testing.T) {
	mList1 := make([]Mapping, 2)
	mList1[0] = Mapping{PosRange{1, 1}, PosRange{3, 3}}
	mList1[1] = Mapping{PosRange{2, 2}, PosRange{4, 4}}

	mList2 := make([]Mapping, 2)
	mList2[0] = Mapping{PosRange{-1, -1}, PosRange{1, 1}}
	mList2[1] = Mapping{PosRange{-1, -1}, PosRange{2, 2}}

	i := 0
	ans := make([]Mapping, 4)
	MergeMappings(mList1, mList2, func(item Mapping) {
		ans[i] = item
		fmt.Println(item)
		i++
	})

	assert.Equal(t, mList2[0], ans[0])
	assert.Equal(t, mList2[1], ans[1])
	assert.Equal(t, mList1[0], ans[2])
	assert.Equal(t, mList1[1], ans[3])
}

func TestMergeMappingsEmptySources(t *testing.T) {
	mList1 := make([]Mapping, 0)
	mList2 := make([]Mapping, 0)
	assert.Panics(t, func() {
		MergeMappings(mList1, mList2, func(item Mapping) {
		})
	})
}
